//
//  LinkRepository.swift
//  Later
//
//  Created by Peter Salmon on 2022-01-04.
//

import Combine
import FirebaseFirestore
import FirebaseFirestoreSwift
import Foundation

// MARK: This is the repository that talks to the Firestore database

final class LinkRepository: ObservableObject {
	// User id stored by firebase, generated by anonymous signIn
	var userId = ""

	// Create an instance of AuthenticationService()
	private let authenticationService = AuthenticationService()

	// Subscriptions to cancel later
	private var cancellables: Set<AnyCancellable> = []

	// Firestore path
	private let path = "links"

	// Firestore store
	private let store = Firestore.firestore()

	// Published list of links for the app
	@Published var links: [LinkItem] = []

	// Get the links upon initialization
	init() {
		// Bind user‘s id from AuthenticationService to the repository’s userId. It also stores the object in cancellables so it can be canceled later.
		authenticationService.$user
			.compactMap { user in
				user?.uid
			}
			.assign(to: \.userId, on: self)
			.store(in: &cancellables)

		// This code observes the changes in user, uses receive(on:options:) to set the thread where the code will execute and then attaches a subscriber using sink(receiveValue:). This guarantees that when you get a user from AuthenticationService, the code in the closure executes in the main thread.
		authenticationService.$user
			.receive(on: DispatchQueue.main)
			.sink { [weak self] _ in
				// Call get, as per usual
				self?.get()
			}
			.store(in: &cancellables)
	}

	func get() {
		store.collection(path)
			// Ensure we are only looking at fields where this user is the user we want
			.whereField("userId", isEqualTo: userId)
			// Listen for changes from the store
			.addSnapshotListener { querySnapshot, error in

				// If an error occurs, print it
				if let error = error {
					print("Error getting links: \(error.localizedDescription)")
					return
				}

				// compactMap() looks at the documents from the query and iterates over
				// if the database is nil, we get an empty array
				self.links = querySnapshot?.documents.compactMap { document in

					// Using FirebaseFirestoreSwift and Codable we are able to directly map the documents to linkitems
					try? document.data(as: LinkItem.self)
				} ?? []
			}
	}

	// Function to add a LinkItem to the Firestore database
	func add(_ item: LinkItem) {
		do {
			var newLink = item
			newLink.userId = userId
			try _ = store.collection(path).addDocument(from: newLink)
		} catch {
			// This kills the app. TODO: add alternative error handling
			fatalError("Unable to add link to database. Error message: \(error.localizedDescription)")
		}
	}

	func update(_ item: LinkItem) {
		/// Ensure the item id has a value, else abort the operation
		guard let itemID = item.id else { return }

		/// If anything goes wrong, terminate the app
		do {
			/// Use the path and document id to find the card in the database and edit it
			try store.collection(path).document(itemID).setData(from: item)
		} catch {
			fatalError("Unable to update link: \(error.localizedDescription)")
		}
	}

	func remove(_ item: LinkItem) {
		guard let itemId = item.id else { return }

		/// Get a reference to the path to the document in firebase and remove it
		store.collection(path).document(itemId).delete { error in
			if let error = error {
				print("Unable to remove link: \(error.localizedDescription)")
			}
		}
	}
}
