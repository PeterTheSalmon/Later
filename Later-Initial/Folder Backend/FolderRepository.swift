//
//  FolderRepository.swift
//  Later
//
//  Created by Peter Salmon on 2022-01-04.
//

import Combine
import FirebaseFirestore
import FirebaseFirestoreSwift
import Foundation

// Observable to emit changes
final class FolderRepository: ObservableObject {
	
	// User id stored by firebase, generated by anonymous signIn
	var userId = ""
	
	// Create an instance of AuthenticationService()
	private let authenticationService = AuthenticationService()
	
	// Subscriptions to cancel later
	private var cancellables: Set<AnyCancellable> = []
	
	// Firestore path
	private let path = "folders"

	// Firestore store
	private let store = Firestore.firestore()

	@Published var folders: [FolderItem] = []

	init() {
		// Bind user‘s id from AuthenticationService to the repository’s userId. It also stores the object in cancellables so it can be canceled later.
		authenticationService.$user
			.compactMap { user in
				user?.uid
			}
			.assign(to: \.userId, on: self)
			.store(in: &cancellables)
		
		// This code observes the changes in user, uses receive(on:options:) to set the thread where the code will execute and then attaches a subscriber using sink(receiveValue:). This guarantees that when you get a user from AuthenticationService, the code in the closure executes in the main thread.
		authenticationService.$user
			.receive(on: DispatchQueue.main)
			.sink { [weak self] _ in
				// Call get, as per usual
				self?.get()
			}
			.store(in: &cancellables)
	}

	func get() {
		store.collection(path)
			.whereField("userId", isEqualTo: userId)
			.addSnapshotListener { querySnapshot, error in
				if let error = error {
					print("Error getting folders: \(error.localizedDescription)")
					return
				}

				self.folders = querySnapshot?.documents.compactMap { document in
					try? document.data(as: FolderItem.self)
				} ?? []
			}
	}

	// Function to add a LinkItem to the Firestore database
	func add(_ item: FolderItem) {
		do {
			var newFolder = item
			newFolder.userId = userId
			try _ = store.collection(path).addDocument(from: newFolder)
		} catch {
			// This kills the app. TODO: add alternative error handling
			fatalError("Unable to add link to database. Error message: \(error.localizedDescription)")
		}
	}
	
	func update(_ item: FolderItem) {
		guard let itemID = item.id else { return }
		
		do {
			// 3
			try store.collection(path).document(itemID).setData(from: item)
		} catch {
			fatalError("Unable to update folder: \(error.localizedDescription).")
		}
	}
	
	func remove(_ item: FolderItem) {
		guard let folderId = item.id else { return }
		
		store.collection(path).document(folderId).delete { error in
			if let error = error {
				print("Unable to remove folder: \(error.localizedDescription)")
			}
		}
	}
}
